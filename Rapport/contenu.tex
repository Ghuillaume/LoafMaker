\chapter{Noyau de l'application}

	L'objectif de l'application finale est de fournir un gestionnaire de tâches (\emph{todolist}) proposant à l'utilisateur des fonctionnalités avancées. Il nous était justement demandé d'implémenter les fonctionnalités suivantes :
	\begin{itemize}
		\item Ajout/Modification/Suppression de tâches, de listes de tâches, et de listes de listes de tâches ;
		\item Gestion de templates de listes de tâches ;
		\item Préconditions à la validation de tâches ;
		\item Permettre d'ordonner les listes ;
		\item Gestion de dates limites (\emph{deadlines}) à une tâche ou à une liste, et pouvant être relatives à une autre date ;
		\item Sauvegarde et chargement XML.
	\end{itemize}

	\section{Analyse}
	
		À partir des fonctionnalités qui nous étaient demandées, nous avons commencé à réfléchir à une conception du noyau de l'application qui nous permettrait une développement rapide au vu du peu de temps qui nous était imparti.\\
		
		À haut niveau, nous avons décidé de manipuler deux principaux types d'objets : les listes et les tâches. Un conteneur, que nous avons appelé modèle, nous servira de référence pour accéder au noyau de l'application. Il s'agit d'une sorte de porte d'accès aux données, un objet contenant une liste des listes ajoutées par l'utilisateur (vector<List*>), et proposant une interface complète permettant au développeur d'agir sur le noyau entier. Un objet liste est lui composé d'une liste de listes (vector<List*> qui seront en fait des sous-listes), et d'une liste de tâches (vector<Task*>). Cette conception nous permet ainsi de bénéficier d'un niveau de profondeur infini. L'ordonnancement des listes sera gérée à plus bas niveau, au niveau de la structure utilisée (vector).
		Nous aurions pu n'utiliser qu'un seul objet Tâche qui aurait les propriétés de nos deux objets, ce qui aurait peut-être permi de simplifier la maintenance de l'application mais qui nous aurait fait perdre du temps sur le développement étant donné l'IHM que nous avons prototypée (différenciation claire des listes et des tâches, voir plus bas).\\
		
		Pour la gestion des dates, nous avons créer notre propre objet Time afin de pouvoir manipuler des dates plus simplement. Ainsi, chaque liste et chaque tâche dispose d'une date limite (ou échéance, deadline). Étant donné que nous voulions proposer une application souple, qui ne contraigne pas l'utilisateur, ces dates sont seulement indicatives et indépendantes, c'est-à-dire qu'une tâche peut avoir une échéance plus lointaine que sa liste. Pour les mêmes raisons, aucune contrainte n'est définie entre l'échéance et les préconditions. Le travail de traitement des échéances a été délégué à l'IHM qui s'occupera tout simplement d'avertir les utilisateurs avec des pictogrammes lorsqu'une date approche ou est dépassée.
		
		Les dates relatives sont quant à elles gérées de manière très simple grâce à un pointeur sur l'objet tâche référente.\\
		
		À propos des templates, nous avons pensé qu'il serait très simple de les considérer comme de simples listes. L'utilisateur créer donc un template comme il créer une liste, ce qui lui donne un point de repère et donc une facilité d'adaptation certain à la fonctionnalité. De même, les templates sont traités de la même manière côté applicatif, puisqu'ils sont stockés dans un objet Liste. Un attribut booléen associé à cet objet nous permettra de différencier les deux objets afin de n'afficher que l'un ou l'autre selon les demandes de la Vue.
		
		Cependant, les templates ont une particularité que n'ont pas les listes : du texte variable. L'utilisateur pourra en effet créer des templates en spécifiant dans le nom de ses sous-listes / tâches une sorte de variable délimitée par un caractère spécial (\% ma\_var \%). Il lui sera ensuite demander de remplir ces variables à la création d'une liste utilisant le template, ce qui lui permettra de créer des templates génériques et prêts à l'emploi.\\
		
		Au final, l'utilisateur pourra ajouter n'importe quelle donnée, celle-ci sera prise en compte et affichée, même si elle n'est pas cohérente. Il s'agit d'un choix que nous avons fait à la conception afin que l'utilisateur puisse faire ce qu'il veut et ne soit pas assailli de pop-up d'avertissement.
		
		
	\section{Fonctionnalités}
	
		\subsection{CRUD listes \& tâches}
			Fonctionnalité proposée par l'objet \emph{Model}.
			
		\subsection{Templates de listes}
			Fonctionne de la même manière qu'une liste de tâches. Fonctionnalité de texte variable non implémentée.
		
		\subsection{Préconditions}
			OK
			
		\subsection{Ordonnancement des tâches}
			Cette fonctionnalité est prise en compte dans le noyau de l'application, mais le changement de l'ordre des tâches n'est pas implémenté.
			
		\subsection{Échéances absolues et relatives}
			Les deux types de date ont été implémentés en utilisant notre objet Time.
		
		\subsection{Sauvegarde et chargement}
			Ces fonctionnalités ont été implémentées mais n'ont pas été testées assez significativement pour être présentées comme robustes.\\
			
			Côté utilisateur, la sauvegarde se fait de manière totalement transparente à la fermeture de l'application, mais également toutes les 5 minutes afin de pallier à un éventuel crash de l'application. L'utilisateur peut également exporter sa sauvegarde pour réutiliser le fichier XML, mais aussi importer d'autres listes grâce à un fichier XML externe (généré d'une autre manière ou pas).
			
			La DTD associée n'est pas fournie mais peut être devinée très simplement.


\chapter{Prototyping (Jerome)}

	\section{Storyboard}
		\begin{figure}[h!]
		   \includegraphics{img/stotyboard_ihm.png}
		   \caption{Storyboard de l'utilisation de l'application}
		\end{figure}
	
		La planche ci-dessus présente les différentes étapes d'utilisation basique du logiciel par un utilisateur lambda (son niveau de compétence n'entre pas ici en compte). Voici la liste des fonctionnalités évoquées et qui devront être présentes dans l'application finale :
		\begin{itemize}
			\item Création de listes imbriquées de tâches;
			\item Paramétrages possibles : dates relatives ou absolues, ordonnancement et dépendance des tâches;
			\item Validation des tâches et affichage de l'avancement;
			\item Sauvegarde en local des modifications effectuées.
		\end{itemize}
	
	\section{Paper-prototype}
	Une \href{https://www.youtube.com/watch?v=xbLaZvgkzjQ}{vidéo sur Youtube} est accessible pour montrer le fonctionnement de l'interface du prototype papier. Le rendu vidéo est en deça de ce à quoi nous nous attendions mais nous n'avons pas eu les conditions optimales (matérielles et logicielles) de production. De plus, nous avons eu très peu de temps pour le prototypage et sommes passés rapidement au développement dès lors que nous avions une interface qui faisait consensus.
	
	
	

	\section{Scénarios d'utilisation}
	
	
	
	\section{Évaluation du prototype}
		Pour avoir un point de vue extérieur, nous avons demandé à un étudiant (qui a souhaité gardé l'anonymat) de nous donner son avis sur le prototype papier. Après plusieurs 
		On a demandé à Péneau ce qu'il pensait de notre paper-prototype, il a dit OK et on a modifié 2-3 trucs :)
		


\chapter{IHM}
	
	\section{Présentation (Guillaume)}
		screens
		dire que y a des popup pour confirmer la suppression (pas faire de caca) ou pour signaler à l'utilisateur que son action n'est pas possible (modifier une tache alors que y en a pas)
	
	\section{Ergonomie (Jerome)}
		Toute la difficulté pour la réalisation de l'interface graphique d'une telle application est de permettre de proposer à l'utilisateur néophyte un rendu clair et intuitif tout en proposant des fonctionnalités plus avancées pour un {\oe}il plus expert. Pour réussir cela, nous avons listé les différentes fonctionnalités souhaitées par ces deux groupes d'utilisateurs et les moyens possibles pour y arriver.
		
		Pour cela, nous avons décider de proposer plusieurs moyens d'arriver aux mêmes fonctionnalités. Par exemple, pour la création de tâches on peut passer par le menu de l'application, le bouton (+) sur la partie droite de l'écran, le clic droit sur cette même partie ou bien le raccourcis clavier. De cette manière, l'utilisateur aura toujours une solution qui lui conviendra plus que les autres et qu'il considèrera comme plus intuitive.
		
		De plus, nous avons choisi de toujours afficher le même menu pour ne pas perdre l'utilisateur avec des \og modes \fg d'utilisation. Ainsi, l'utilisateur aura toujours les mêmes repères visuels. Cela est important, en particulier pour les débutants, qui ne peuvent pas se raccrocher à leur expérience avec d'autres logiciels similaires.\newline
		
		Pour rendre l'utilisation plus intuitive, nous avons aussi décidé d'intégrer des icônes colorées, explicites et facilement reconnaissables pour limiter la quantité de texte à l'écran. Pour cela, nous avons utilisé des images tirées de la bibliothèque du projet \emph{Gnome}\footnote{\href{https://commons.wikimedia.org/wiki/GNOME_Desktop_icons}{Icônes disponibles ici.}} et disponibles sous licence GNU General Public License version 2. Les avantages de ces icônes sont nombreux : gratuits, libres, ergonomiques et disponibles en de nombreuses tailles, \dots \newline
		
		Nous avons souhaité permettre à l'utilisateur de contrôler dans une certaine mesure la taille des panneaux, c'est pourquoi nous avons permis d'agrandir l'un ou l'autre des côtés de la vue avec un /emph{splitter} vertical pour une meilleure lisibilité.
		
		En plus de cela, nous affichons une petite aide lors du lancement du programme pour permettre une prise en main rapide et aisée. En effet, le panneau dédié aux liste de tâche est temporairement remplacé par un message de bienvenue qui avertit l'utilisateur sur le fonctionnement du logiciel.
		
		
	\section{Structure des widgets}
	
		\begin{figure}[h!]
		   \includegraphics{struct_widget.png}
		   \caption{Structure des widgets}
		\end{figure}
		\FloatBarrier
		
		
		
	
\chapter{Limites de l'application (TOUS)}

	Blabla sur les bugs et autres limitations
	
	\section{Fonctionnalités CRUD}
	
		\begin{itemize}
			\item Lors de la suppression d'une liste, il peut arrive que l'application crash. Ce bug étant apparu assez tardivement dans le développement de l'application, nous n'avons pas eu le temps de le corriger ;
			\item Lors de la création, de la modification et de la suppression d'une liste, l'arbre des listes ne se met pas à jour correctement, et l'utilisateur est obligé de sélectionner à nouveau sa liste pour pouvoir y apporter des modifications ;
		\end{itemize}
		
		
	\section{IHM}
	
		\begin{itemize}
			\item Au départ, nous voulions donner à l'utilisateur la possibilité d'agrandir ou de réduire la taille de la fenêtre, ainsi que de mettre l'application en plein écran. Nous n'avons malheureusement pas eu le temps de pousser le développement jusque là ;
		\end{itemize}


\chapter{Évaluations (TOUS)}
	
	Utilisateurs néophytes :
		Ma mère et ma soeur
		Ta mère
		
	Utilisateurs avancés :
		Pierre-Yves
		Leroux

